{"0": {
    "doc": "Unreal入门，门01，自动开启的门",
    "title": "Unreal入门，门01，自动开启的门",
    "content": " ",
    "url": "/docs/Hello/Unreal/001Door/001TheDoor01.html",
    
    "relUrl": "/docs/Hello/Unreal/001Door/001TheDoor01.html"
  },"1": {
    "doc": "并差集",
    "title": "并查集",
    "content": "并查集（Disjoint Set）是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。 . 并查集的主要操作如下： . | makeSet(s)：建立一个新的并查集，其中包含s个单元素集合。 | unionSet(x, y)：若x和y不在同一集合，则将x和y所在的集合合并为一个集合。 | findSet(x)：查找元素x所在的集合，返回该集合的代表元素。 | . 并查集的基本思想是维护一个由树组成的森林，其中每个节点都有一个父节点指针指向它的父节点。初始时，每个节点自成一个集合，即它们的父节点都指向自己。每次进行合并操作时，将两个集合的根节点连接起来，使其中一个根节点成为另一个根节点的子节点。这样，就可以通过检查某个节点的祖先，来确定它所属的集合。 . 并查集的主要优点是在合并和查询操作中具有较高的效率，时间复杂度均为O(log n)。并查集常用于解决图论中的连通性问题，如最小生成树、最大流等算法中。 . ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%B9%B6%E6%9F%A5%E9%9B%86",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#并查集"
  },"2": {
    "doc": "并差集",
    "title": "LeetCode 547. 省份数量",
    "content": "有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 . 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 . 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 . 返回矩阵中 省份 的数量。 . ",
    "url": "/docs/Other/LeetCode/001union_find.html#leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#leetcode-547-省份数量"
  },"3": {
    "doc": "并差集",
    "title": "并差集题解",
    "content": " ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%B9%B6%E5%B7%AE%E9%9B%86%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#并差集题解"
  },"4": {
    "doc": "并差集",
    "title": "1. 初始化，确定各个城市省份关系之前，先假定每个城市都是一个省份，省份就是自己，差不多就是直辖市的感觉",
    "content": ". // MAX_CITY_N城市数量 int city[MAX_CITY_N]; void init() { // 用索引id代表城市，数组的值代表省份id for (int i=0; i&lt;MAX_CITY_N; i++) { // 自己就是自己的省份，省份值即城市id city[i] = i; } } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A1%AE%E5%AE%9A%E5%90%84%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9C%81%E4%BB%BD%E5%85%B3%E7%B3%BB%E4%B9%8B%E5%89%8D%E5%85%88%E5%81%87%E5%AE%9A%E6%AF%8F%E4%B8%AA%E5%9F%8E%E5%B8%82%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E7%9C%81%E4%BB%BD%E7%9C%81%E4%BB%BD%E5%B0%B1%E6%98%AF%E8%87%AA%E5%B7%B1%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%B0%B1%E6%98%AF%E7%9B%B4%E8%BE%96%E5%B8%82%E7%9A%84%E6%84%9F%E8%A7%89",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#1-初始化确定各个城市省份关系之前先假定每个城市都是一个省份省份就是自己差不多就是直辖市的感觉"
  },"5": {
    "doc": "并差集",
    "title": "2. 基本合并算法，两个城市如果直接相连，则表示它们属于同一个省份，将其中一个的省份值设置为对方的省份值",
    "content": ". city[indexB] = city[indexA]; . 或者反过来（这里先以上面的为准） . city[indexA] = city[indexB]; . 2.1 继续合并，假设B和C相连，将C的省份值设置为B的省份值 . city[indexC] = city[indexB]; . 实际上前面的操作之后，B的省份值是A的省份值 . city[indexC] = city[indexA]; . ",
    "url": "/docs/Other/LeetCode/001union_find.html#2-%E5%9F%BA%E6%9C%AC%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95%E4%B8%A4%E4%B8%AA%E5%9F%8E%E5%B8%82%E5%A6%82%E6%9E%9C%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%E5%88%99%E8%A1%A8%E7%A4%BA%E5%AE%83%E4%BB%AC%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9C%81%E4%BB%BD%E5%B0%86%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%9A%84%E7%9C%81%E4%BB%BD%E5%80%BC%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%AF%B9%E6%96%B9%E7%9A%84%E7%9C%81%E4%BB%BD%E5%80%BC",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#2-基本合并算法两个城市如果直接相连则表示它们属于同一个省份将其中一个的省份值设置为对方的省份值"
  },"6": {
    "doc": "并差集",
    "title": "3. 根省份与查找算法，前面合并之后B和C的省份都变成了A，而A的省份也是A，这里就可以将A确认为根省份了，这里就可以确认查找根省份的算法了：",
    "content": "// 返回省份值，也是一个cityIndex int find(int cityIndex) { // 假定从indexC开始查找，递归到indexA // city[indexA] == indexA，则indexA是indexC的省份 if (city[cityIndex] == cityIndex) { return cityIndex; } // city[indexC] != indexC，所以需要继续find return find(city[cityIndex]); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#3-%E6%A0%B9%E7%9C%81%E4%BB%BD%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%89%8D%E9%9D%A2%E5%90%88%E5%B9%B6%E4%B9%8B%E5%90%8Eb%E5%92%8Cc%E7%9A%84%E7%9C%81%E4%BB%BD%E9%83%BD%E5%8F%98%E6%88%90%E4%BA%86a%E8%80%8Ca%E7%9A%84%E7%9C%81%E4%BB%BD%E4%B9%9F%E6%98%AFa%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86a%E7%A1%AE%E8%AE%A4%E4%B8%BA%E6%A0%B9%E7%9C%81%E4%BB%BD%E4%BA%86%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%A1%AE%E8%AE%A4%E6%9F%A5%E6%89%BE%E6%A0%B9%E7%9C%81%E4%BB%BD%E7%9A%84%E7%AE%97%E6%B3%95%E4%BA%86",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#3-根省份与查找算法前面合并之后b和c的省份都变成了a而a的省份也是a这里就可以将a确认为根省份了这里就可以确认查找根省份的算法了"
  },"7": {
    "doc": "并差集",
    "title": "4. 基于根省份的合并算法，将其中一个城市的根省份赋值给另一个城市的根省份",
    "content": "void merge(int indexA, int indexB) { // 先查找A城市的根省份 int rootProvinceOfA = find(indexA); // 然后将A城市的根省份作为B城市的新省份 city[indexB] = rootProvinceOfA; } . 简化一下： . void merge(int indexA, int indexB) { city[indexB] = find(indexA); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#4-%E5%9F%BA%E4%BA%8E%E6%A0%B9%E7%9C%81%E4%BB%BD%E7%9A%84%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95%E5%B0%86%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E6%A0%B9%E7%9C%81%E4%BB%BD%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E6%A0%B9%E7%9C%81%E4%BB%BD",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#4-基于根省份的合并算法将其中一个城市的根省份赋值给另一个城市的根省份"
  },"8": {
    "doc": "并差集",
    "title": "4.1 合并问题，如果出现下图的关系，按照上面的算法，会导致最终结算出两个根节点，而实际上它们都是联通的，只应该出现一个根节点，所以合并的时候需要先定位到根节点，让根节点去参与合并操作",
    "content": ". | 根节点不准问题 merge(A, B); // 连线AB，A为根 merge(A, D); // 连线AD，A为根 merge(C, D); // 连线CD，D的根变成了C，出现了AC两个根，但是它们实际都是联通的 . | 所以合并算法需要考虑让两个节点的根节点相互联通，而不只是其中一个作为根参与联通 | . void merge(int indexA, int indexB) { int rootOfA = find(indexA); int rootOfB = find(indexB); city[rootOfB] = rootOfA; } . 简化一下： . void merge(int indexA, int indexB) { city[find(indexB)] = find(indexA); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#41-%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E4%B8%8B%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB%E6%8C%89%E7%85%A7%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%AE%97%E6%B3%95%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%9C%80%E7%BB%88%E7%BB%93%E7%AE%97%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E8%80%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%AE%83%E4%BB%AC%E9%83%BD%E6%98%AF%E8%81%94%E9%80%9A%E7%9A%84%E5%8F%AA%E5%BA%94%E8%AF%A5%E5%87%BA%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E6%89%80%E4%BB%A5%E5%90%88%E5%B9%B6%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E8%AE%A9%E6%A0%B9%E8%8A%82%E7%82%B9%E5%8E%BB%E5%8F%82%E4%B8%8E%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#41-合并问题如果出现下图的关系按照上面的算法会导致最终结算出两个根节点而实际上它们都是联通的只应该出现一个根节点所以合并的时候需要先定位到根节点让根节点去参与合并操作"
  },"9": {
    "doc": "并差集",
    "title": "4.2 合并成链问题，下面这种合并顺序下，搜索路径会变成一条长长的链条，搜索的时间复杂度退化成O(n)，这里可以考虑增加一个深度信息，合并的时候，让深度值高的根节点作为新的根",
    "content": ". | 合并成链问题 merge(C, D); // 连线CD，C为根 merge(B, C); // 连线BC，B为根 merge(A, B); // 连线AB，A为根 . | 深度值高的作为新的根 merge(C, D); // 连线CD，C为根 merge(B, C); // 连线BC，C深度为2，B深度为1，C作为新的根 merge(A, B); // 连线AB，B的根是C，所以这里是连接AC，C的深度当前为3，所以C继续作为新的根 . | 新的初始化，带深度信息 // MAX_CITY_N城市数量 int city[MAX_CITY_N]; int depth[MAX_CITY_N]; void init() { // 用索引id代表城市，数组的值代表省份id for (int i=0; i&lt;MAX_CITY_N; i++) { // 自己就是自己的省份，省份值即城市id city[i] = i; depth[i] = 1; } } . | 新的合并算法 void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } . | . ",
    "url": "/docs/Other/LeetCode/001union_find.html#42-%E5%90%88%E5%B9%B6%E6%88%90%E9%93%BE%E9%97%AE%E9%A2%98%E4%B8%8B%E9%9D%A2%E8%BF%99%E7%A7%8D%E5%90%88%E5%B9%B6%E9%A1%BA%E5%BA%8F%E4%B8%8B%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E4%BC%9A%E5%8F%98%E6%88%90%E4%B8%80%E6%9D%A1%E9%95%BF%E9%95%BF%E7%9A%84%E9%93%BE%E6%9D%A1%E6%90%9C%E7%B4%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%80%80%E5%8C%96%E6%88%90on%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E4%BF%A1%E6%81%AF%E5%90%88%E5%B9%B6%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%A9%E6%B7%B1%E5%BA%A6%E5%80%BC%E9%AB%98%E7%9A%84%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BD%9C%E4%B8%BA%E6%96%B0%E7%9A%84%E6%A0%B9",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#42-合并成链问题下面这种合并顺序下搜索路径会变成一条长长的链条搜索的时间复杂度退化成on这里可以考虑增加一个深度信息合并的时候让深度值高的根节点作为新的根"
  },"10": {
    "doc": "并差集",
    "title": "5. 统计省份，只用统计根节点即可",
    "content": "int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { // 索引和当前的值相等即为根节点 if (city[i] == i) { counter++; } } return counter; } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#5-%E7%BB%9F%E8%AE%A1%E7%9C%81%E4%BB%BD%E5%8F%AA%E7%94%A8%E7%BB%9F%E8%AE%A1%E6%A0%B9%E8%8A%82%E7%82%B9%E5%8D%B3%E5%8F%AF",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#5-统计省份只用统计根节点即可"
  },"11": {
    "doc": "并差集",
    "title": "6. 完整代码",
    "content": "#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; class UnionFind { public: UnionFind(int n) : depth(n, 1){ city.reserve(n); for (int i = 0; i &lt; n; i++) { city.push_back(i); } } int find(int cityIndex) const { if (city[cityIndex] == cityIndex) { return cityIndex; } return find(city[cityIndex]); } void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { if (city[i] == i) { counter++; } } return counter; } private: vector&lt;int&gt; city; vector&lt;int&gt; depth; }; class Solution { public: static int findCircleNum(const vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { UnionFind uf(isConnected.size()); for (int i = 0; i &lt; isConnected.size(); i++) { for (int j = 0; j &lt; isConnected[i].size(); j++) { if (isConnected[i][j]) { uf.merge(i, j); } } } return uf.count(); } }; void Test() { // 2 vector&lt;vector&lt;int&gt;&gt; isConnected = { {1,1,0}, {1,1,0}, {0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; // 3 isConnected = { {1,0,0}, {0,1,0}, {0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; // 3 isConnected = { {1,1,0,0,0,0,0,1,0,0,0,0,0,0,0}, {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,1,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,1,0,1,1,0,0,0,0,0,0,0,0}, {0,0,0,0,1,0,0,0,0,1,1,0,0,0,0}, {0,0,0,1,0,1,0,0,0,0,1,0,0,0,0}, {0,0,0,1,0,0,1,0,1,0,0,0,0,1,0}, {1,0,0,0,0,0,0,1,1,0,0,0,0,0,0}, {0,0,0,0,0,0,1,1,1,0,0,0,0,1,0}, {0,0,0,0,1,0,0,0,0,1,0,1,0,0,1}, {0,0,0,0,1,1,0,0,0,0,1,1,0,0,0}, {0,0,0,0,0,0,0,0,0,1,1,1,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}, {0,0,0,0,0,0,1,0,1,0,0,0,0,1,0}, {0,0,0,0,0,0,0,0,0,1,0,0,0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#6-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#6-完整代码"
  },"12": {
    "doc": "并差集",
    "title": "参考",
    "content": "[1] 并查集 Disjoint-set data structure https://en.wikipedia.org/wiki/Disjoint-set_data_structure . [2] LeetCode 547. 省份数量 https://leetcode.cn/problems/number-of-provinces/description/ . [2] LeetCode 695. 岛屿的最大面积 https://leetcode.cn/problems/max-area-of-island/description/ . ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#参考"
  },"13": {
    "doc": "并差集",
    "title": "并差集",
    "content": " ",
    "url": "/docs/Other/LeetCode/001union_find.html",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html"
  },"14": {
    "doc": "Unreal入门，门02，锁住的门",
    "title": "Unreal入门，门02，锁住的门",
    "content": " ",
    "url": "/docs/Hello/Unreal/001Door/002TheDoor02.html",
    
    "relUrl": "/docs/Hello/Unreal/001Door/002TheDoor02.html"
  },"15": {
    "doc": "并差集 - Kruskal算法",
    "title": "Kruskal算法",
    "content": "Kruskal算法是一种常用的最小生成树算法，用于在给定无向连通图中找到最小生成树。最小生成树是一个连通子图，它包含了原图的所有顶点，并且具有最小的总权重或代价。 . Kruskal算法的基本思想是从图中的边集合中逐步选择边，直到形成一个最小生成树。它的步骤如下： . | 将图中的所有边按照权重进行排序。 | 创建一个空的最小生成树集合。 | 依次遍历排序后的边集合，选择权重最小的边。 | 如果选择的边不会导致形成环路（即不会与已选择的边构成闭环），则将该边添加到最小生成树集合中。 | 重复步骤4，直到最小生成树集合中包含了所有顶点（或边的数量达到了顶点数减1）。 | . Kruskal算法的关键在于判断边是否会导致形成环路。为了实现这一点，通常使用并查集数据结构来维护顶点之间的连接关系。 . 通过使用Kruskal算法，我们可以在一个连通图中找到一棵最小生成树，该树具有最小的总权重或代价。这在许多应用中都是有用的，如网络设计、电力传输、城市规划等。 . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#kruskal%E7%AE%97%E6%B3%95",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#kruskal算法"
  },"16": {
    "doc": "并差集 - Kruskal算法",
    "title": "最小生成树问题",
    "content": ". ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#最小生成树问题"
  },"17": {
    "doc": "并差集 - Kruskal算法",
    "title": "题解",
    "content": " ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#题解"
  },"18": {
    "doc": "并差集 - Kruskal算法",
    "title": "1. 特化的并差集问题，根据题目的要求，需要联通所有村庄，套用到并差集上相当于是所有节点都处于同一个集合中，只有一个根节点，这里根据Kruskal算法，一步一步构建出最优并差集解即可",
    "content": "1.1 并差集初始化，自己作为自己的根（为了方便理解，这里没有做查询优化） . // MAX_NODE_N节点数量 int city[MAX_NODE_N]; void init() { for (int i=0; i&lt;MAX_NODE_N; i++) { // 默认自己就是自己的根节点 city[i] = i; } } . 1.2 并差集查找，递归查找根节点 . // 返回根节点索引 int find(int nodeIndex) { // 假定从indexC开始查找，递归到indexA // city[indexA] == indexA，则indexA是indexC的省份 if (city[nodeIndex] == nodeIndex) { return nodeIndex; } // city[indexC] != indexC，所以需要继续find return find(city[nodeIndex]); } . 1.3 并差集合并，只有根节点参与合并 . | 这里图示第三步中，会递归查找D的根节点A，最后是CA进行合并，C变成新的根节点（因为没有做优化，所以这里不是保持A作为根节点） void merge(int indexA, int indexB) { city[find(indexB)] = find(indexA); } . | . 1.4 并差集查询节点联通性，即判断两个节点是否存在相同的根节点 . bool connected(int indexA, int indexB) { return find(indexA) == find(indexB); } . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#1-%E7%89%B9%E5%8C%96%E7%9A%84%E5%B9%B6%E5%B7%AE%E9%9B%86%E9%97%AE%E9%A2%98%E6%A0%B9%E6%8D%AE%E9%A2%98%E7%9B%AE%E7%9A%84%E8%A6%81%E6%B1%82%E9%9C%80%E8%A6%81%E8%81%94%E9%80%9A%E6%89%80%E6%9C%89%E6%9D%91%E5%BA%84%E5%A5%97%E7%94%A8%E5%88%B0%E5%B9%B6%E5%B7%AE%E9%9B%86%E4%B8%8A%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%98%AF%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E9%83%BD%E5%A4%84%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E8%BF%99%E9%87%8C%E6%A0%B9%E6%8D%AEkruskal%E7%AE%97%E6%B3%95%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%9E%84%E5%BB%BA%E5%87%BA%E6%9C%80%E4%BC%98%E5%B9%B6%E5%B7%AE%E9%9B%86%E8%A7%A3%E5%8D%B3%E5%8F%AF",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#1-特化的并差集问题根据题目的要求需要联通所有村庄套用到并差集上相当于是所有节点都处于同一个集合中只有一个根节点这里根据kruskal算法一步一步构建出最优并差集解即可"
  },"19": {
    "doc": "并差集 - Kruskal算法",
    "title": "2. 应用Kruskal算法",
    "content": "2.1 边权排序，升序排列 . vector&lt;vector&lt;int&gt;&gt; cost; std::sort(cost.begin(), cost.end(), [](const vector&lt;int&gt; &amp;edgeX, const vector&lt;int&gt; &amp;edgeY)-&gt;bool{ return edgeX[2] &lt; edgeY[2]; }) . 2.2 从最小边开始构建并差集，即最小生成树 . UnionFind uf(cost.size()); for(const auto &amp;edge: cost) { // 为了避免形成环，需要判断两个节点是否已经联通 if(!uf.connected(edge[0], edge[1])) { // 构建最小生成树 uf.merge(edge[0], edge[1]); } } . 2.3 最小费用计算，前面构建最小生成树的过程中，将边权加起来即可 . int total_cost = 0; for(const auto &amp;edge: cost) { if(!uf.connected(edge[0], edge[1])) { // 构建最小生成树 uf.merge(edge[0], edge[1]); // 计算最小费用 total_cost += edge[2]; } } . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#2-%E5%BA%94%E7%94%A8kruskal%E7%AE%97%E6%B3%95",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#2-应用kruskal算法"
  },"20": {
    "doc": "并差集 - Kruskal算法",
    "title": "3. 完整代码",
    "content": "class UnionFind { public: UnionFind(int n) : depth(n, 1) { city.reserve(n); for (int i = 0; i &lt; n; i++) { city.push_back(i); } } int find(int cityIndex) const { if (city[cityIndex] == cityIndex) { return cityIndex; } return find(city[cityIndex]); } void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { if (city[i] == i) { counter++; } } return counter; } bool connected(int indexA, int indexB) const { return find(indexA) == find(indexB); } private: vector&lt;int&gt; city; vector&lt;int&gt; depth; }; class Kruskal { public: Kruskal(int nodeSize, vector&lt;vector&lt;int&gt;&gt;&amp;&amp; costData) : uf(nodeSize), cost(costData) { // 边权排序 std::sort(cost.begin(), cost.end(), [](const vector&lt;int&gt;&amp; edgeX, const vector&lt;int&gt;&amp; edgeY)-&gt;bool { return edgeX[2] &lt; edgeY[2]; }); // 构建最小生成树 for (const auto&amp; edge : cost) { // cost是一个二维数组，edge是长度为3的一维数组 // 索引0和1存的两个相连的节点索引值，索引2存的连接两个节点的费用 // 数据是从1开始的，并差集用的数据是从0开始的，所以这里要-1 if (!uf.connected(edge[0] - 1, edge[1] - 1)) { uf.merge(edge[0] - 1, edge[1] - 1); total_cost += edge[2]; } } } int MinCost() const { return total_cost; } private: vector&lt;vector&lt;int&gt;&gt; cost; UnionFind uf; int total_cost{0}; }; class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * 返回最小的花费代价使得这n户人家连接起来 * @param n int整型 n户人家的村庄 * @param m int整型 m条路 * @param cost int整型vector&lt;vector&lt;&gt;&gt; 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价 * @return int整型 */ int miniSpanningTree(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; cost) { // write code here Kruskal kal(n, std::move(cost)); return kal.MinCost(); } }; . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#3-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#3-完整代码"
  },"21": {
    "doc": "并差集 - Kruskal算法",
    "title": "参考",
    "content": "[1] Kruskal’s algorithm https://en.wikipedia.org/wiki/Kruskal%27s_algorithm . [2] 并查集 Disjoint-set data structure https://en.wikipedia.org/wiki/Disjoint-set_data_structure . [3] LeetCode 1135. 最低成本联通所有城市 https://leetcode.cn/problems/connecting-cities-with-minimum-cost/description/ . [4] LeetCode 1584. 连接所有点的最小费用 https://leetcode.cn/problems/min-cost-to-connect-all-points/description/ . [5] 最小生成树 https://www.nowcoder.com/practice/735a34ff4672498b95660f43b7fcd628 . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#参考"
  },"22": {
    "doc": "并差集 - Kruskal算法",
    "title": "并差集 - Kruskal算法",
    "content": " ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html"
  },"23": {
    "doc": "Prim算法",
    "title": "Prim算法",
    "content": "Prim算法是一种常用的最小生成树算法，用于在给定无向连通图中找到最小生成树。最小生成树是一个连通子图，它包含了原图的所有顶点，并且具有最小的总权重或代价。 . Prim算法的基本思想是从一个初始顶点开始，逐步地选择与当前最小生成树集合相连的最小权重边，并将其添加到最小生成树中。它的步骤如下： . | 选择一个初始顶点，将其加入最小生成树集合。 | 从已选择的顶点集合中找到与之相连的边，并选择权重最小的边。 | 将选择的边加入最小生成树集合，并将该边的另一个顶点加入已选择的顶点集合。 | 重复步骤2和步骤3，直到最小生成树集合中包含了所有顶点（或边的数量达到了顶点数减1）。 | . Prim算法使用一个优先队列（通常是最小堆）来选择权重最小的边。在每一步中，它选择与当前最小生成树集合相连的顶点中具有最小权重的边。这保证了每次选择的边都是当前最小生成树集合和未选择顶点集合之间的最小权重边。 . 通过使用Prim算法，我们可以在一个连通图中找到一棵最小生成树，该树具有最小的总权重或代价。这在许多应用中都是有用的，如网络设计、电力传输、城市规划等。 . ",
    "url": "/docs/Other/LeetCode/003prim.html",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html"
  },"24": {
    "doc": "Prim算法",
    "title": "leetcode 1584. 连接所有点的最小费用",
    "content": "给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。 . 连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。 . 请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。 . ",
    "url": "/docs/Other/LeetCode/003prim.html#leetcode-1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#leetcode-1584-连接所有点的最小费用"
  },"25": {
    "doc": "Prim算法",
    "title": "题解",
    "content": " ",
    "url": "/docs/Other/LeetCode/003prim.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#题解"
  },"26": {
    "doc": "Prim算法",
    "title": "1. 确认初始顶点，Prim算法并没有规定初始点怎么选，这里可以任选，默认取索引为0的点",
    "content": "// 所有顶点，n×2的二维数组，每行记录了点的坐标 vector&lt;vector&lt;int&gt;&gt; points; // 辅助数组，表示每个点是否已经被确认为已连接，避免重复搜索 vector&lt;bool&gt; connected(points.size(), false); // 用索引来表示所有的点，初始确认连接的点为0 // 你要设为其它索引作为其实点也行，反正最后都要连上的 int start_index = 0; // 初始顶点已连接 connected[start_index] = true; // 初始顶点已连接 vector&lt;int&gt; path; path.push_back(start_index); . ",
    "url": "/docs/Other/LeetCode/003prim.html#1-%E7%A1%AE%E8%AE%A4%E5%88%9D%E5%A7%8B%E9%A1%B6%E7%82%B9prim%E7%AE%97%E6%B3%95%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%A7%84%E5%AE%9A%E5%88%9D%E5%A7%8B%E7%82%B9%E6%80%8E%E4%B9%88%E9%80%89%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E4%BB%BB%E9%80%89%E9%BB%98%E8%AE%A4%E5%8F%96%E7%B4%A2%E5%BC%95%E4%B8%BA0%E7%9A%84%E7%82%B9",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#1-确认初始顶点prim算法并没有规定初始点怎么选这里可以任选默认取索引为0的点"
  },"27": {
    "doc": "Prim算法",
    "title": "2. 确认下一个连接点，在当前已经确定的点中查找最小边来确认新的点",
    "content": "2.1 曼哈顿距离计算，这一步可以提前算好存到一个预计算距离数组中，以便提升程序执行速度（空间换时间） . // 计算曼哈顿距离 int Distance(int indexA, int indexB) { return std::abs(points[indexA][0] - points[indexB][0]) + std::abs(points[indexA][1] - points[indexB][1]); } // 存了所有坐标点距离的邻接矩阵缓存 vector&lt;vector&lt;int&gt;&gt; distance_cache; // 预计算所有坐标点的距离 void CalcAllDistance(vector&lt;vector&lt;int&gt;&gt; &amp;pts) { for (int i = 0; i &lt; pts.size(); i++) { for (int j = i + 1; j &lt; pts.size(); j++) { distance_cache[i][j] = distance_cache[j][i] = Distance(i, j); } } } . 2.2 在已连接的点集中查找最小边 . int total_cost = 0; // 最小总费用 // 查找最小边 void FindMinEdge() { int min_edge = INT_MAX; // 下一个最小边 int min_point = -1; // 下一个连接最小边的点 // 查找最小边 for(auto pt: path) { for(int i=0; i&lt;points.size(); i++) { // 排除和自己连接 &amp;&amp; 排除已连接 &amp;&amp; 最小距离 if(pt!=i &amp;&amp; !connected[i] &amp;&amp; distance(pt, i)&lt;min_edge)) { min_point = i; min_edge = distance(pt, i); } } } // 找到最小边后更新总费用和已连接数列 if (min_point &gt; 0 &amp;&amp; min_edge &gt; 0) { path.push_back(min_point); connected[min_point] = true; total_cost += min_edge; } } . 2.3 确认全部最小路径 . // 查找确认最小路径 while (path.size() &lt; points.size()) { FindMinEdge(); } . ",
    "url": "/docs/Other/LeetCode/003prim.html#2-%E7%A1%AE%E8%AE%A4%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5%E7%82%B9%E5%9C%A8%E5%BD%93%E5%89%8D%E5%B7%B2%E7%BB%8F%E7%A1%AE%E5%AE%9A%E7%9A%84%E7%82%B9%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E8%BE%B9%E6%9D%A5%E7%A1%AE%E8%AE%A4%E6%96%B0%E7%9A%84%E7%82%B9",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#2-确认下一个连接点在当前已经确定的点中查找最小边来确认新的点"
  },"28": {
    "doc": "Prim算法",
    "title": "3. 优化，上面的时间复杂度已经达到O(n^3)级别了，执行速度有点一言难尽",
    "content": "3.1 这里增加一个min_cost数组用来存剩余节点距离当前节点的最短距离 . 当前只有起始节点一个节点的时候很好理解，min_cost空间复杂度为O(n) . // 最短距离 vector&lt;int&gt; min_cost(points.size(), INT_MAX); // 初始确认连接的点为0 int start_index = 0; // 其它点到起始点的距离 for (int i = 0; i &lt; points.size(); i++) { if (i != start_index) min_cost[i] = distance_cache[start_index][i]; } . 3.2 依据min_cost数据来查找最小边 . int min_edge = INT_MAX; // 下一个最小边 int min_point = -1; // 下一个连接最小边的点 for (int i = 0; i &lt; points.size(); i++) { // 排除已连接 &amp;&amp; 最小距离 if (!connected[i] &amp;&amp; min_cost[i] &lt; min_edge) { min_point = i; min_edge = min_cost[i]; } } . 3.3 渐进式更新min_cost数组 . 正常思维，存点阵之间相互的最短连接距离一般得要O(n^2)的时间复杂度，就是一开始用到的方法，每个已连接节点算一遍到剩余节点的距离，每次大循环都需要重新算一遍，就比较费时 . 这里因为起始点已经算过，假设我们从第二个已连接点开始算，依次计算剩余点到新连接点的距离，如果有比上一轮距离起始点还短的距离，则抛弃旧路径，保留新路径 . // 更新最短距离数列 for (int i = 0; i &lt; points.size(); i++) { // 排除已连接 &amp;&amp; 比当前最小边还小 if(!connected[i] &amp;&amp; min_cost[i] &gt; distance_cache[i][min_point]) min_cost[i] = distance_cache[i][min_point]; } . ",
    "url": "/docs/Other/LeetCode/003prim.html#3-%E4%BC%98%E5%8C%96%E4%B8%8A%E9%9D%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%B7%B2%E7%BB%8F%E8%BE%BE%E5%88%B0on3%E7%BA%A7%E5%88%AB%E4%BA%86%E6%89%A7%E8%A1%8C%E9%80%9F%E5%BA%A6%E6%9C%89%E7%82%B9%E4%B8%80%E8%A8%80%E9%9A%BE%E5%B0%BD",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#3-优化上面的时间复杂度已经达到on3级别了执行速度有点一言难尽"
  },"29": {
    "doc": "Prim算法",
    "title": "4. 完整代码",
    "content": "class Prim { public: Prim(vector&lt;vector&lt;int&gt;&gt;&amp;&amp; pts) : distance_cache(pts.size(), vector&lt;int&gt;(pts.size(), 0)) , min_cost(pts.size(), INT_MAX) , connected(pts.size(), false) , points(pts) { // 预计算所有坐标点的距离 CalcAllDistance(points); // 初始确认连接的点为0 int start_index = 0; // 你要设为其它索引作为其实点也行，反正最后都要连上的 connected[start_index] = true; path.push_back(start_index); // 其它点到起始点的距离 for (int i = 0; i &lt; points.size(); i++) { if (i != start_index) min_cost[i] = distance_cache[start_index][i]; } // 查找确认最小路径 while (path.size() &lt; points.size()) { FindMinEdge(); } } int MinCost() const { return total_cost; } private: // 计算曼哈顿距离 int Distance(int indexA, int indexB) { return std::abs(points[indexA][0] - points[indexB][0]) + std::abs(points[indexA][1] - points[indexB][1]); } // 预计算所有坐标点的距离 void CalcAllDistance(vector&lt;vector&lt;int&gt;&gt; &amp;pts) { for (int i = 0; i &lt; pts.size(); i++) { for (int j = i + 1; j &lt; pts.size(); j++) { distance_cache[i][j] = distance_cache[j][i] = Distance(i, j); } } } // 查找最小边 void FindMinEdge() { // 下一个最小边 int min_edge = INT_MAX; // 下一个连接最小边的点 int min_point = -1; for (int i = 0; i &lt; points.size(); i++) { // 排除已连接 &amp;&amp; 最小距离 if (!connected[i] &amp;&amp; min_cost[i] &lt; min_edge) { min_point = i; min_edge = min_cost[i]; } } // 找到最小边后更新总费用和已连接数列 if (min_point &gt; 0 &amp;&amp; min_edge &gt; 0) { path.push_back(min_point); connected[min_point] = true; total_cost += min_edge; } // 更新最短距离数列 for (int i = 0; i &lt; points.size(); i++) { // 排除已连接 &amp;&amp; 比当前最小边还小 if(!connected[i] &amp;&amp; min_cost[i] &gt; distance_cache[i][min_point]) min_cost[i] = distance_cache[i][min_point]; } } private: // 存了所有坐标点距离的邻接矩阵缓存 vector&lt;vector&lt;int&gt;&gt; distance_cache; // 最短距离 vector&lt;int&gt; min_cost; // 辅助数组，表示每个点是否已经被确认为已连接，避免重复搜索 vector&lt;bool&gt; connected; // points是一个二维数组，每行存了一个点的XY坐标 vector&lt;vector&lt;int&gt;&gt; points; // 已经确定的连接点的索引数列 vector&lt;int&gt; path; // 最小总费用 int total_cost{ 0 }; }; class Solution { public: static int minCostConnectPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) { Prim p(std::move(points)); return p.MinCost(); } }; void Test() { // 20 vector&lt;vector&lt;int&gt;&gt; pts = { {0,0},{2,2},{3,10},{5,2},{7,0}}; cout &lt;&lt; Solution::minCostConnectPoints(pts) &lt;&lt; endl; // 351638 pts = { {-5698,-8233},{1026,4797},{8195,8437},{3498,-9980},{5222,-4322},{-5589,-7532},{2098,-3463},{-9603,-3604},{-6057,8315},{-1259,2835},{-728,-4985},{-7736,-1357},{-3403,912},{307,3130},{-7891,-1896},{5347,4345},{-4634,718},{205,-9439},{5061,2060},{-6672,-9647},{5682,7606},{-1954,-5638},{9478,-2673},{-1520,-3300},{4245,7018},{-9850,-1419},{9311,-4321},{-8522,9196},{8161,4077},{78,6893},{-250,3376},{-5764,-6641},{-9870,-2137},{6358,477},{2145,-6866},{2677,1564},{-394,-8628},{-9669,2688},{-6124,8802},{4731,-6891},{6841,-4542},{-849,-5183},{-5049,6470},{752,9487},{-2382,-787},{-2679,7391},{-4088,4983},{9609,7633},{5588,-4217},{2029,9029},{5166,2772},{-2614,2036},{9452,5837},{-1398,-4690},{5367,-9452},{2557,4278},{3018,8427},{-5050,-3043},{-3402,9306},{5905,-886},{-5711,7472},{-4855,-7741},{-3874,-8015},{6662,7579},{7111,5400},{-6518,835},{8744,7618},{-5018,6824},{2967,1579},{-9125,1051},{4453,3851},{1745,-1764},{4243,2062},{9773,7988},{-908,9980},{4519,7744},{-5959,8796},{-1050,-8178},{496,7536},{161,4729},{-2559,-2468},{-8038,-6269},{-2701,-3586},{3054,-4072},{-5171,2062},{-6688,3479},{4423,-3834},{-8404,-723},{-1316,8726},{-2303,-1381},{4793,5648},{-4862,5489},{-772,-8258},{851,-9830},{-5218,-5705},{-5323,7785},{-7762,-8046},{7317,1475},{1820,-4586},{2150,140},{-4643,4190},{-2389,-5398},{-786,-9999},{5768,-208},{5908,-3623},{-869,5566},{-3238,6606},{-1247,6673},{113,-9718},{-1819,-7680},{9333,1395},{-9716,-9202},{-5926,3456},{-1893,-2083},{-6634,-1278},{-5122,-8749},{8528,1204},{-1210,-2230},{-2195,4983},{9539,-4935},{-2339,5310},{-153,-7579},{4629,-7497},{294,-6041},{7572,-8638},{3024,-4783},{-2416,2260},{-3728,2560},{-6499,3001},{7706,6003},{8700,5144},{-54,6420},{-5355,7235},{-7327,7085},{1379,7006},{-6631,4364},{8590,-2063},{124,-991},{4997,-732},{8748,-2321},{8827,-5733},{-9958,7106},{6999,9696},{-6653,4769},{-6316,8075},{-5669,-1720},{5473,-2215},{4798,8281},{4174,-717},{9465,-6092},{7763,9754},{-2942,-4927},{-9770,-2867},{-8570,4194},{-801,6443},{-7374,3245},{-5159,-1232},{189,9554},{-9721,-27},{6907,-6585},{-859,-3675},{-6841,8855},{8934,-9852},{1675,-7822},{-6489,-8706},{-7575,6401},{-546,178},{5666,-6399},{6841,7530},{4665,-7514},{-1565,-1960},{-3214,3199},{-8671,8382},{-1780,-2431},{5434,-8329},{-6027,-2661},{8458,-9085},{881,-5237},{-2343,6666},{5584,-9490},{4027,5207},{-4352,8676},{-4678,110},{-6308,3922},{6848,9570},{-2108,-2837},{-6291,-4718},{1659,4767},{1723,-4909},{-5944,-6446},{6548,9498},{-8475,-1982},{4598,-3275},{8346,5422},{5298,-6086},{2005,-7830},{-4528,3574},{5557,-9429},{-8988,-4465},{-5814,-9101},{2809,5688},{1525,5986},{-2094,-4340},{2089,7047},{-6276,2758},{423,2767},{4590,-5166},{5637,5134},{8738,-3710},{-418,6321},{-3450,-9162},{-6105,-8925},{285,-6936},{-6194,6073},{4258,1301},{-5567,-1161},{4306,-2707},{1113,5653},{-4610,-2182},{1987,-24},{1374,4615},{1320,5650},{-9531,5679},{1195,1394},{-8347,-8318},{114,438},{-6603,-3452},{-6512,-9403},{2763,3338},{-4136,3306},{1350,-958},{6573,-4548},{-5830,-7189},{6149,-2963},{-6957,1571},{-2225,-7921},{-6151,6881},{-2954,3537},{628,3738},{8103,6531},{-1959,821},{-8322,1729},{3933,-6371},{-2922,-2509},{-8441,-3109},{2677,3230},{8645,3667},{-6378,-3285},{8870,-4684},{-8930,2032},{-3529,1453},{637,-5024},{-8292,2526},{5663,-5360},{-8694,-2729},{-8333,-1188},{-5749,2871},{2538,-9028},{-5990,-118},{7641,-1651},{-1312,5346},{8578,-4859},{-9958,9666},{4485,-4112},{4067,-3731},{-4199,-6144},{-9647,-6230},{-5366,-6184},{-803,-7515},{2075,3361},{3442,828},{3661,1253},{-6315,-4061},{214,-6752},{4305,3912},{-8961,9710},{4404,8651},{3338,-7},{-2860,6387},{5744,2278},{4214,-7730},{-1884,-7994},{5151,8701},{-3897,8828},{-8642,5586},{3482,7427},{-9509,1333},{-2108,5560},{-3340,7145},{8741,2428},{-5170,1157},{690,-9469},{-312,1334},{-8163,-2838},{-7934,-7494},{7417,-9102},{-5876,-9336},{-5080,-7916},{-5536,9034},{6545,-1656},{4362,498},{-917,933},{-7214,5875},{1411,1117},{-3357,5667},{-3406,3817},{-3980,-9798},{-4892,797},{-8927,8941},{-2861,-5003},{-3183,2331},{1632,-9390},{6131,1978},{8993,9089},{-2151,-9220},{-8772,-6323},{-2458,6153},{8078,-4117},{-3571,3464},{-877,-7206},{6074,-5182},{-9085,-4133},{-6966,-4049},{9538,-8572},{7752,-196},{6887,8882},{-7154,7452},{-1800,7320},{-9736,7263},{1265,7537},{4684,-8260},{2572,4413},{-2022,1650},{2676,-3224},{5784,-2351},{-52,1375},{8735,-7509},{3338,9006},{7267,3251},{-1434,-7395},{6737,-4749},{68,6977},{-9757,-9738},{6935,-9525},{3486,5691},{4894,-6794},{5658,-2055},{2907,-9576},{-6947,-4678},{-9639,7740},{-6644,-7749},{-1758,4464},{-1164,-7809},{1320,8410},{-4209,5625},{-5332,6191},{3355,-155},{6578,-1843},{-8754,-8416},{-2439,-3218},{2036,-4770},{-484,-9929},{653,5591},{-7623,9241},{-6899,6623},{-7281,-4130},{3617,1483},{7161,-4357},{8987,-1159},{1849,1262},{-9027,8958},{992,-420},{1220,-6801},{-9770,-3730},{5156,4240},{-8355,-1884},{-5820,-358},{6255,8001},{-7344,-4709},{-8505,8209},{-9564,-9172},{1032,-604},{-1083,-2613},{-2190,-6519},{1882,-8574},{-5445,-2921},{7177,358},{2256,-8305},{790,8004},{1089,-1798},{8344,-921},{-8075,-59},{-4279,2544},{-3052,-9733},{-985,3404},{-3351,-6341},{-6097,-7971},{-3188,-4125},{2824,5943},{2294,-6651},{-920,-6433},{-6783,4957},{-9948,7901},{-7464,3816},{-6063,-1903},{791,-8022},{-2200,-7450},{2480,1872},{-6795,5060},{9765,413},{9183,9179},{4942,8703},{-8213,-654},{4930,2730},{6358,6589},{8222,-9670},{9857,1241},{4159,-269},{7318,2587},{-9114,2789},{-5124,-9881},{-5525,7263},{-7584,-1725},{9413,-3888},{-9749,2216},{-8622,-419},{3274,-8722},{6234,-6800},{-9116,7304},{-8765,-471},{-7918,-9246},{5972,-470},{3310,7609},{8711,2677},{-2045,5514},{-5871,17},{-9705,2204},{6577,297},{7771,6640},{-1002,-3492},{-2487,-9394},{6992,-3892},{9585,-9475},{8108,6050},{-9513,-5036},{-9110,750},{-1192,1627},{9879,-9908},{-4519,-2218},{-6230,6680},{-9091,7684},{-6892,4007},{9652,6787}}; cout &lt;&lt; Solution::minCostConnectPoints(pts) &lt;&lt; endl; } . ",
    "url": "/docs/Other/LeetCode/003prim.html#4-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#4-完整代码"
  },"30": {
    "doc": "Prim算法",
    "title": "Prim算法和Kruskal算法的区别",
    "content": "Prim算法和Kruskal算法都是用于求解最小生成树的经典算法，它们的主要区别在于实现方式和时间复杂度。 . Prim算法是一种贪心算法，其基本思想是从一个任意选定的起始节点开始，每次选择与当前生成树相邻的最短边的另一个端点加入到生成树中，直到所有节点都被加入到生成树中为止。该算法可以使用堆优化的方式，时间复杂度为O(ElogV)，其中E和V分别为边数和顶点数。 . Kruskal算法也是一种贪心算法，其基本思想是将所有边按照权值从小到大排序，然后逐步加入边，如果加入某条边会形成环，则舍弃该边，直到所有节点都被加入到生成树中为止。该算法使用并查集来判断是否形成环，时间复杂度为O(ElogE)，其中E为边数。 . 因此，Prim算法更适用于稠密图（即边数较多），而Kruskal算法更适用于稀疏图（即边数较少）。此外，Prim算法的空间复杂度比Kruskal算法小，因为Prim算法只需要存储每个节点到生成树的最短距离，而Kruskal算法需要存储每个节点所在的集合。 . ",
    "url": "/docs/Other/LeetCode/003prim.html#prim%E7%AE%97%E6%B3%95%E5%92%8Ckruskal%E7%AE%97%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#prim算法和kruskal算法的区别"
  },"31": {
    "doc": "Prim算法",
    "title": "参考",
    "content": "[0] Prim’s algorithm https://en.wikipedia.org/wiki/Prim%27s_algorithm . [1] leetcode 1584. 连接所有点的最小费用 https://leetcode.cn/problems/min-cost-to-connect-all-points/description/ . [2] 计程车几何（Taxicab geometry）或曼哈顿距离 https://en.wikipedia.org/wiki/Taxicab_geometry . ",
    "url": "/docs/Other/LeetCode/003prim.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/LeetCode/003prim.html#参考"
  },"32": {
    "doc": "Excel单元格数值统计",
    "title": "题解",
    "content": "#include &lt;iostream&gt; . ",
    "url": "/docs/Other/LeetCode/101excel_count.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/101excel_count.html#题解"
  },"33": {
    "doc": "Excel单元格数值统计",
    "title": "Excel单元格数值统计",
    "content": ". ",
    "url": "/docs/Other/LeetCode/101excel_count.html",
    
    "relUrl": "/docs/Other/LeetCode/101excel_count.html"
  },"34": {
    "doc": "Linux发行版的数量",
    "title": "题解",
    "content": "#include &lt;iostream&gt; . ",
    "url": "/docs/Other/LeetCode/102linux_count.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/102linux_count.html#题解"
  },"35": {
    "doc": "Linux发行版的数量",
    "title": "Linux发行版的数量",
    "content": ". ",
    "url": "/docs/Other/LeetCode/102linux_count.html",
    
    "relUrl": "/docs/Other/LeetCode/102linux_count.html"
  },"36": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "1. 安装ImageMagick",
    "content": "sudo apt-get update sudo apt-get install imagemagick . ",
    "url": "/docs/Other/Tools/ImageMagick.html#1-%E5%AE%89%E8%A3%85imagemagick",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#1-安装imagemagick"
  },"37": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "2. 图片压缩基本指令",
    "content": "# -monitor 显示进度 # -fuzz 5% 颜色容差（color fuzz factor） # -layers Optimize 对图层进行优化处理 convert -monitor timeline05.gif -fuzz 5% -layers Optimize magick_timeline05.gif . ",
    "url": "/docs/Other/Tools/ImageMagick.html#2-%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#2-图片压缩基本指令"
  },"38": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "3. 利用Makefile一键全部压缩成magick_前缀的图片",
    "content": "# 定义 ImageMagick 命令和压缩质量变量 IMAGEMAGICK = convert FUZZ = 5% # 查找当前目录下所有未压缩的图片文件 ORIGINAL_IMAGES := $(wildcard *.png) $(wildcard *.jpg) $(wildcard *.jpeg) $(wildcard *.gif) # 过滤出需要压缩的图片文件（不包括带有前缀 \"magick_\" 的图片） TO_COMPRESS_IMAGES := $(filter-out magick_%, $(ORIGINAL_IMAGES)) # 将压缩后的图片文件名加上前缀 \"magick_\" COMPRESSED_IMAGES := $(addprefix magick_, $(TO_COMPRESS_IMAGES)) # 定义压缩所有图片的规则 compress: $(COMPRESSED_IMAGES) # 定义每个图片的压缩规则 $(COMPRESSED_IMAGES): magick_% : % @echo \"Compressing $&lt;...\" $(IMAGEMAGICK) -monitor $&lt; -fuzz $(FUZZ) -layers Optimize $@ # 定义清除所有压缩后的图片的规则 clean: rm -f magick_* . ",
    "url": "/docs/Other/Tools/ImageMagick.html#3-%E5%88%A9%E7%94%A8makefile%E4%B8%80%E9%94%AE%E5%85%A8%E9%83%A8%E5%8E%8B%E7%BC%A9%E6%88%90magick_%E5%89%8D%E7%BC%80%E7%9A%84%E5%9B%BE%E7%89%87",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#3-利用makefile一键全部压缩成magick_前缀的图片"
  },"39": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "压缩率非常惊人",
    "content": ". ",
    "url": "/docs/Other/Tools/ImageMagick.html#%E5%8E%8B%E7%BC%A9%E7%8E%87%E9%9D%9E%E5%B8%B8%E6%83%8A%E4%BA%BA",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#压缩率非常惊人"
  },"40": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "参考",
    "content": ". | 运行环境：Windows wsl, ubuntu20.04.6 | https://imagemagick.org/script/command-line-options.php | . ",
    "url": "/docs/Other/Tools/ImageMagick.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#参考"
  },"41": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "利用ImageMagick进行图片压缩",
    "content": " ",
    "url": "/docs/Other/Tools/ImageMagick.html",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html"
  },"42": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com . You can find the source code for Minima at GitHub: jekyll / minima . You can find the source code for Jekyll at GitHub: jekyll / jekyll . ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"43": {
    "doc": "Home",
    "title": "Hello World!",
    "content": " ",
    "url": "/#hello-world",
    
    "relUrl": "/#hello-world"
  },"44": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"45": {
    "doc": "Other",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "/docs/Other/#ui-components",
    
    "relUrl": "/docs/Other/#ui-components"
  },"46": {
    "doc": "Other",
    "title": "Other",
    "content": " ",
    "url": "/docs/Other/",
    
    "relUrl": "/docs/Other/"
  },"47": {
    "doc": "Tools",
    "title": "Tools",
    "content": " ",
    "url": "/docs/Other/Tools/",
    
    "relUrl": "/docs/Other/Tools/"
  },"48": {
    "doc": "LeetCode",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "/docs/Other/LeetCode/#ui-components",
    
    "relUrl": "/docs/Other/LeetCode/#ui-components"
  },"49": {
    "doc": "LeetCode",
    "title": "LeetCode",
    "content": " ",
    "url": "/docs/Other/LeetCode/",
    
    "relUrl": "/docs/Other/LeetCode/"
  },"50": {
    "doc": "Unreal",
    "title": "Hello Unreal",
    "content": " ",
    "url": "/docs/Hello/Unreal/#hello-unreal",
    
    "relUrl": "/docs/Hello/Unreal/#hello-unreal"
  },"51": {
    "doc": "Unreal",
    "title": "Unreal",
    "content": " ",
    "url": "/docs/Hello/Unreal/",
    
    "relUrl": "/docs/Hello/Unreal/"
  },"52": {
    "doc": "Hello",
    "title": "Hello",
    "content": " ",
    "url": "/docs/Hello/",
    
    "relUrl": "/docs/Hello/"
  }
}
