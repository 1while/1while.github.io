{"0": {
    "doc": "Unreal入门，门01，自动开启的门",
    "title": "Unreal入门，门01，自动开启的门",
    "content": " ",
    "url": "/docs/Hello/Unreal/001Door/001TheDoor01.html",
    
    "relUrl": "/docs/Hello/Unreal/001Door/001TheDoor01.html"
  },"1": {
    "doc": "并差集",
    "title": "并查集",
    "content": "并查集（Disjoint Set）是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。 . 并查集的主要操作如下： . | makeSet(s)：建立一个新的并查集，其中包含s个单元素集合。 | unionSet(x, y)：若x和y不在同一集合，则将x和y所在的集合合并为一个集合。 | findSet(x)：查找元素x所在的集合，返回该集合的代表元素。 | . 并查集的基本思想是维护一个由树组成的森林，其中每个节点都有一个父节点指针指向它的父节点。初始时，每个节点自成一个集合，即它们的父节点都指向自己。每次进行合并操作时，将两个集合的根节点连接起来，使其中一个根节点成为另一个根节点的子节点。这样，就可以通过检查某个节点的祖先，来确定它所属的集合。 . 并查集的主要优点是在合并和查询操作中具有较高的效率，时间复杂度均为O(log n)。并查集常用于解决图论中的连通性问题，如最小生成树、最大流等算法中。 . ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%B9%B6%E6%9F%A5%E9%9B%86",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#并查集"
  },"2": {
    "doc": "并差集",
    "title": "LeetCode 547. 省份数量",
    "content": "有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 . 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 . 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 . 返回矩阵中 省份 的数量。 . ",
    "url": "/docs/Other/LeetCode/001union_find.html#leetcode-547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#leetcode-547-省份数量"
  },"3": {
    "doc": "并差集",
    "title": "并差集题解",
    "content": " ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%B9%B6%E5%B7%AE%E9%9B%86%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#并差集题解"
  },"4": {
    "doc": "并差集",
    "title": "1. 初始化，确定各个城市省份关系之前，先假定每个城市都是一个省份，省份就是自己，差不多就是直辖市的感觉",
    "content": ". // MAX_CITY_N城市数量 int city[MAX_CITY_N]; void init() { // 用索引id代表城市，数组的值代表省份id for (int i=0; i&lt;MAX_CITY_N; i++) { // 自己就是自己的省份，省份值即城市id city[i] = i; } } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A1%AE%E5%AE%9A%E5%90%84%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9C%81%E4%BB%BD%E5%85%B3%E7%B3%BB%E4%B9%8B%E5%89%8D%E5%85%88%E5%81%87%E5%AE%9A%E6%AF%8F%E4%B8%AA%E5%9F%8E%E5%B8%82%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E7%9C%81%E4%BB%BD%E7%9C%81%E4%BB%BD%E5%B0%B1%E6%98%AF%E8%87%AA%E5%B7%B1%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%B0%B1%E6%98%AF%E7%9B%B4%E8%BE%96%E5%B8%82%E7%9A%84%E6%84%9F%E8%A7%89",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#1-初始化确定各个城市省份关系之前先假定每个城市都是一个省份省份就是自己差不多就是直辖市的感觉"
  },"5": {
    "doc": "并差集",
    "title": "2. 基本合并算法，两个城市如果直接相连，则表示它们属于同一个省份，将其中一个的省份值设置为对方的省份值",
    "content": ". city[indexB] = city[indexA]; . 或者反过来（这里先以上面的为准） . city[indexA] = city[indexB]; . 2.1 继续合并，假设B和C相连，将C的省份值设置为B的省份值 . city[indexC] = city[indexB]; . 实际上前面的操作之后，B的省份值是A的省份值 . city[indexC] = city[indexA]; . ",
    "url": "/docs/Other/LeetCode/001union_find.html#2-%E5%9F%BA%E6%9C%AC%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95%E4%B8%A4%E4%B8%AA%E5%9F%8E%E5%B8%82%E5%A6%82%E6%9E%9C%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%E5%88%99%E8%A1%A8%E7%A4%BA%E5%AE%83%E4%BB%AC%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9C%81%E4%BB%BD%E5%B0%86%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%9A%84%E7%9C%81%E4%BB%BD%E5%80%BC%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%AF%B9%E6%96%B9%E7%9A%84%E7%9C%81%E4%BB%BD%E5%80%BC",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#2-基本合并算法两个城市如果直接相连则表示它们属于同一个省份将其中一个的省份值设置为对方的省份值"
  },"6": {
    "doc": "并差集",
    "title": "3. 根省份与查找算法，前面合并之后B和C的省份都变成了A，而A的省份也是A，这里就可以将A确认为根省份了，这里就可以确认查找根省份的算法了：",
    "content": "// 返回省份值，也是一个cityIndex int find(int cityIndex) { // 假定从indexC开始查找，递归到indexA // city[indexA] == indexA，则indexA是indexC的省份 if (city[cityIndex] == cityIndex) { return cityIndex; } // city[indexC] != indexC，所以需要继续find return find(city[cityIndex]); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#3-%E6%A0%B9%E7%9C%81%E4%BB%BD%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%89%8D%E9%9D%A2%E5%90%88%E5%B9%B6%E4%B9%8B%E5%90%8Eb%E5%92%8Cc%E7%9A%84%E7%9C%81%E4%BB%BD%E9%83%BD%E5%8F%98%E6%88%90%E4%BA%86a%E8%80%8Ca%E7%9A%84%E7%9C%81%E4%BB%BD%E4%B9%9F%E6%98%AFa%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86a%E7%A1%AE%E8%AE%A4%E4%B8%BA%E6%A0%B9%E7%9C%81%E4%BB%BD%E4%BA%86%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%A1%AE%E8%AE%A4%E6%9F%A5%E6%89%BE%E6%A0%B9%E7%9C%81%E4%BB%BD%E7%9A%84%E7%AE%97%E6%B3%95%E4%BA%86",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#3-根省份与查找算法前面合并之后b和c的省份都变成了a而a的省份也是a这里就可以将a确认为根省份了这里就可以确认查找根省份的算法了"
  },"7": {
    "doc": "并差集",
    "title": "4. 基于根省份的合并算法，将其中一个城市的根省份赋值给另一个城市的根省份",
    "content": "void merge(int indexA, int indexB) { // 先查找A城市的根省份 int rootProvinceOfA = find(indexA); // 然后将A城市的根省份作为B城市的新省份 city[indexB] = rootProvinceOfA; } . 简化一下： . void merge(int indexA, int indexB) { city[indexB] = find(indexA); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#4-%E5%9F%BA%E4%BA%8E%E6%A0%B9%E7%9C%81%E4%BB%BD%E7%9A%84%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95%E5%B0%86%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E6%A0%B9%E7%9C%81%E4%BB%BD%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E6%A0%B9%E7%9C%81%E4%BB%BD",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#4-基于根省份的合并算法将其中一个城市的根省份赋值给另一个城市的根省份"
  },"8": {
    "doc": "并差集",
    "title": "4.1 合并问题，如果出现下图的关系，按照上面的算法，会导致最终结算出两个根节点，而实际上它们都是联通的，只应该出现一个根节点，所以合并的时候需要先定位到根节点，让根节点去参与合并操作",
    "content": ". | 根节点不准问题 merge(A, B); // 连线AB，A为根 merge(A, D); // 连线AD，A为根 merge(C, D); // 连线CD，D的根变成了C，出现了AC两个根，但是它们实际都是联通的 . | 所以合并算法需要考虑让两个节点的根节点相互联通，而不只是其中一个作为根参与联通 | . void merge(int indexA, int indexB) { int rootOfA = find(indexA); int rootOfB = find(indexB); city[rootOfB] = rootOfA; } . 简化一下： . void merge(int indexA, int indexB) { city[find(indexB)] = find(indexA); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#41-%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E4%B8%8B%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB%E6%8C%89%E7%85%A7%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%AE%97%E6%B3%95%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%9C%80%E7%BB%88%E7%BB%93%E7%AE%97%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E8%80%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%AE%83%E4%BB%AC%E9%83%BD%E6%98%AF%E8%81%94%E9%80%9A%E7%9A%84%E5%8F%AA%E5%BA%94%E8%AF%A5%E5%87%BA%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E6%89%80%E4%BB%A5%E5%90%88%E5%B9%B6%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E8%AE%A9%E6%A0%B9%E8%8A%82%E7%82%B9%E5%8E%BB%E5%8F%82%E4%B8%8E%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#41-合并问题如果出现下图的关系按照上面的算法会导致最终结算出两个根节点而实际上它们都是联通的只应该出现一个根节点所以合并的时候需要先定位到根节点让根节点去参与合并操作"
  },"9": {
    "doc": "并差集",
    "title": "4.2 合并成链问题，下面这种合并顺序下，搜索路径会变成一条长长的链条，搜索的时间复杂度退化成O(n)，这里可以考虑增加一个深度信息，合并的时候，让深度值高的根节点作为新的根",
    "content": ". | 合并成链问题 merge(C, D); // 连线CD，C为根 merge(B, C); // 连线BC，B为根 merge(A, B); // 连线AB，A为根 . | 深度值高的作为新的根 merge(C, D); // 连线CD，C为根 merge(B, C); // 连线BC，C深度为2，B深度为1，C作为新的根 merge(A, B); // 连线AB，B的根是C，所以这里是连接AC，C的深度当前为3，所以C继续作为新的根 . | 新的初始化，带深度信息 // MAX_CITY_N城市数量 int city[MAX_CITY_N]; int depth[MAX_CITY_N]; void init() { // 用索引id代表城市，数组的值代表省份id for (int i=0; i&lt;MAX_CITY_N; i++) { // 自己就是自己的省份，省份值即城市id city[i] = i; depth[i] = 1; } } . | 新的合并算法 void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } . | . ",
    "url": "/docs/Other/LeetCode/001union_find.html#42-%E5%90%88%E5%B9%B6%E6%88%90%E9%93%BE%E9%97%AE%E9%A2%98%E4%B8%8B%E9%9D%A2%E8%BF%99%E7%A7%8D%E5%90%88%E5%B9%B6%E9%A1%BA%E5%BA%8F%E4%B8%8B%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E4%BC%9A%E5%8F%98%E6%88%90%E4%B8%80%E6%9D%A1%E9%95%BF%E9%95%BF%E7%9A%84%E9%93%BE%E6%9D%A1%E6%90%9C%E7%B4%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%80%80%E5%8C%96%E6%88%90on%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E4%BF%A1%E6%81%AF%E5%90%88%E5%B9%B6%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%A9%E6%B7%B1%E5%BA%A6%E5%80%BC%E9%AB%98%E7%9A%84%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BD%9C%E4%B8%BA%E6%96%B0%E7%9A%84%E6%A0%B9",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#42-合并成链问题下面这种合并顺序下搜索路径会变成一条长长的链条搜索的时间复杂度退化成on这里可以考虑增加一个深度信息合并的时候让深度值高的根节点作为新的根"
  },"10": {
    "doc": "并差集",
    "title": "5. 统计省份，只用统计根节点即可",
    "content": "int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { // 索引和当前的值相等即为根节点 if (city[i] == i) { counter++; } } return counter; } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#5-%E7%BB%9F%E8%AE%A1%E7%9C%81%E4%BB%BD%E5%8F%AA%E7%94%A8%E7%BB%9F%E8%AE%A1%E6%A0%B9%E8%8A%82%E7%82%B9%E5%8D%B3%E5%8F%AF",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#5-统计省份只用统计根节点即可"
  },"11": {
    "doc": "并差集",
    "title": "6. 完整代码",
    "content": "#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; namespace UnionFindTest { class UnionFind { public: UnionFind(int n) : depth(n, 1){ city.reserve(n); for (int i = 0; i &lt; n; i++) { city.push_back(i); } } int find(int cityIndex) const { if (city[cityIndex] == cityIndex) { return cityIndex; } return find(city[cityIndex]); } void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { if (city[i] == i) { counter++; } } return counter; } private: vector&lt;int&gt; city; vector&lt;int&gt; depth; }; class Solution { public: static int findCircleNum(const vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { UnionFind uf(isConnected.size()); for (int i = 0; i &lt; isConnected.size(); i++) { for (int j = 0; j &lt; isConnected[i].size(); j++) { if (isConnected[i][j]) { uf.merge(i, j); } } } return uf.count(); } }; void Test() { // 2 vector&lt;vector&lt;int&gt;&gt; isConnected = { {1,1,0}, {1,1,0}, {0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; // 3 isConnected = { {1,0,0}, {0,1,0}, {0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; // 3 isConnected = { {1,1,0,0,0,0,0,1,0,0,0,0,0,0,0}, {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,1,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,1,0,1,1,0,0,0,0,0,0,0,0}, {0,0,0,0,1,0,0,0,0,1,1,0,0,0,0}, {0,0,0,1,0,1,0,0,0,0,1,0,0,0,0}, {0,0,0,1,0,0,1,0,1,0,0,0,0,1,0}, {1,0,0,0,0,0,0,1,1,0,0,0,0,0,0}, {0,0,0,0,0,0,1,1,1,0,0,0,0,1,0}, {0,0,0,0,1,0,0,0,0,1,0,1,0,0,1}, {0,0,0,0,1,1,0,0,0,0,1,1,0,0,0}, {0,0,0,0,0,0,0,0,0,1,1,1,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}, {0,0,0,0,0,0,1,0,1,0,0,0,0,1,0}, {0,0,0,0,0,0,0,0,0,1,0,0,0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; } } // namespace UnionFindTest . ",
    "url": "/docs/Other/LeetCode/001union_find.html#6-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#6-完整代码"
  },"12": {
    "doc": "并差集",
    "title": "参考",
    "content": "[1] 并查集 https://zh.wikipedia.org/zh-cn/%E5%B9%B6%E6%9F%A5%E9%9B%86 . [2] LeetCode 547. 省份数量 https://leetcode.cn/problems/number-of-provinces/description/ . [2] LeetCode 695. 岛屿的最大面积 https://leetcode.cn/problems/max-area-of-island/description/ . ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#参考"
  },"13": {
    "doc": "并差集",
    "title": "并差集",
    "content": " ",
    "url": "/docs/Other/LeetCode/001union_find.html",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html"
  },"14": {
    "doc": "Unreal入门，门02，锁住的门",
    "title": "Unreal入门，门02，锁住的门",
    "content": " ",
    "url": "/docs/Hello/Unreal/001Door/002TheDoor02.html",
    
    "relUrl": "/docs/Hello/Unreal/001Door/002TheDoor02.html"
  },"15": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "Kruskal算法",
    "content": "Kruskal算法是一种常用的最小生成树算法，用于在给定无向连通图中找到最小生成树。最小生成树是一个连通子图，它包含了原图的所有顶点，并且具有最小的总权重或代价。 . Kruskal算法的基本思想是从图中的边集合中逐步选择边，直到形成一个最小生成树。它的步骤如下： . | 将图中的所有边按照权重进行排序。 | 创建一个空的最小生成树集合。 | 依次遍历排序后的边集合，选择权重最小的边。 | 如果选择的边不会导致形成环路（即不会与已选择的边构成闭环），则将该边添加到最小生成树集合中。 | 重复步骤4，直到最小生成树集合中包含了所有顶点（或边的数量达到了顶点数减1）。 | . Kruskal算法的关键在于判断边是否会导致形成环路。为了实现这一点，通常使用并查集数据结构来维护顶点之间的连接关系。 . 通过使用Kruskal算法，我们可以在一个连通图中找到一棵最小生成树，该树具有最小的总权重或代价。这在许多应用中都是有用的，如网络设计、电力传输、城市规划等。 . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#kruskal%E7%AE%97%E6%B3%95",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#kruskal算法"
  },"16": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "最小生成树问题",
    "content": ". ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#最小生成树问题"
  },"17": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "题解",
    "content": " ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#题解"
  },"18": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "1. 特化的并差集问题，根据题目的要求，需要联通所有村庄，套用到并差集上相当于是所有节点都处于同一个集合中，只有一个根节点，这里根据Kruskal算法，一步一步构建出最优并差集解即可",
    "content": "1.1 并差集初始化，自己作为自己的根（为了方便理解，这里没有做查询优化） . // MAX_NODE_N节点数量 int city[MAX_NODE_N]; void init() { for (int i=0; i&lt;MAX_NODE_N; i++) { // 默认自己就是自己的根节点 city[i] = i; } } . 1.2 并差集查找，递归查找根节点 . // 返回根节点索引 int find(int nodeIndex) { // 假定从indexC开始查找，递归到indexA // city[indexA] == indexA，则indexA是indexC的省份 if (city[nodeIndex] == nodeIndex) { return nodeIndex; } // city[indexC] != indexC，所以需要继续find return find(city[nodeIndex]); } . 1.3 并差集合并，只有根节点参与合并 . | 这里图示第三步中，会递归查找D的根节点A，最后是CA进行合并，C变成新的根节点（因为没有做优化，所以这里不是保持A作为根节点） void merge(int indexA, int indexB) { city[find(indexB)] = find(indexA); } . | . 1.4 并差集查询节点联通性，即判断两个节点是否存在相同的根节点 . bool connected(int indexA, int indexB) { return find(indexA) == find(indexB); } . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#1-%E7%89%B9%E5%8C%96%E7%9A%84%E5%B9%B6%E5%B7%AE%E9%9B%86%E9%97%AE%E9%A2%98%E6%A0%B9%E6%8D%AE%E9%A2%98%E7%9B%AE%E7%9A%84%E8%A6%81%E6%B1%82%E9%9C%80%E8%A6%81%E8%81%94%E9%80%9A%E6%89%80%E6%9C%89%E6%9D%91%E5%BA%84%E5%A5%97%E7%94%A8%E5%88%B0%E5%B9%B6%E5%B7%AE%E9%9B%86%E4%B8%8A%E7%9B%B8%E5%BD%93%E4%BA%8E%E6%98%AF%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9%E9%83%BD%E5%A4%84%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%AD%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E8%BF%99%E9%87%8C%E6%A0%B9%E6%8D%AEkruskal%E7%AE%97%E6%B3%95%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%9E%84%E5%BB%BA%E5%87%BA%E6%9C%80%E4%BC%98%E5%B9%B6%E5%B7%AE%E9%9B%86%E8%A7%A3%E5%8D%B3%E5%8F%AF",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#1-特化的并差集问题根据题目的要求需要联通所有村庄套用到并差集上相当于是所有节点都处于同一个集合中只有一个根节点这里根据kruskal算法一步一步构建出最优并差集解即可"
  },"19": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "2. 应用Kruskal算法",
    "content": "2.1 边权排序，升序排列 . vector&lt;vector&lt;int&gt;&gt; cost; std::sort(cost.begin(), cost.end(), [](const vector&lt;int&gt; &amp;edgeX, const vector&lt;int&gt; &amp;edgeY)-&gt;bool{ return edgeX[2] &lt; edgeY[2]; }) . 2.2 从最小边开始构建并差集，即最小生成树 . UnionFind uf(cost.size()); for(const auto &amp;edge: cost) { // 为了避免形成环，需要判断两个节点是否已经联通 if(!uf.connected(edge[0], edge[1])) { uf.merge(edge[0], edge[1]); } } . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#2-%E5%BA%94%E7%94%A8kruskal%E7%AE%97%E6%B3%95",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#2-应用kruskal算法"
  },"20": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "3. 完整代码",
    "content": "class UnionFind { public: UnionFind(int n) : depth(n, 1) { city.reserve(n); for (int i = 0; i &lt; n; i++) { city.push_back(i); } } int find(int cityIndex) const { if (city[cityIndex] == cityIndex) { return cityIndex; } return find(city[cityIndex]); } void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { if (city[i] == i) { counter++; } } return counter; } bool connected(int indexA, int indexB) { return find(indexA) == find(indexB); } private: vector&lt;int&gt; city; vector&lt;int&gt; depth; }; class Kruskal { public: Kruskal(int nodeSize, vector&lt;vector&lt;int&gt;&gt;&amp;&amp; costData) : uf(nodeSize), cost(costData) { // 边权排序 std::sort(cost.begin(), cost.end(), [](const vector&lt;int&gt;&amp; edgeX, const vector&lt;int&gt;&amp; edgeY)-&gt;bool { return edgeX[2] &lt; edgeY[2]; }); // 构建最小生成树 for (const auto&amp; edge : cost) { // cost是一个二维数组，edge是长度为3的一维数组 // 索引0和1存的两个相连的节点索引值，索引2存的连接两个节点的费用 // 数据是从1开始的，并差集用的数据是从0开始的，所以这里要-1 if (!uf.connected(edge[0] - 1, edge[1] - 1)) { uf.merge(edge[0] - 1, edge[1] - 1); total_cost += edge[2]; } } } int MinCost() const { return total_cost; } private: vector&lt;vector&lt;int&gt;&gt; cost; UnionFind uf; int total_cost{0}; }; class Solution { public: /** * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可 * * 返回最小的花费代价使得这n户人家连接起来 * @param n int整型 n户人家的村庄 * @param m int整型 m条路 * @param cost int整型vector&lt;vector&lt;&gt;&gt; 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价 * @return int整型 */ int miniSpanningTree(int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; cost) { // write code here Kruskal kal(n, std::move(cost)); return kal.MinCost(); } }; . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#3-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#3-完整代码"
  },"21": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "参考",
    "content": "[1] Kruskal’s algorithm https://zh.wikipedia.org/wiki/%E5%85%8B%E9%B2%81%E6%96%AF%E5%85%8B%E5%B0%94%E6%BC%94%E7%AE%97%E6%B3%95 . [2] 并查集 https://zh.wikipedia.org/zh-cn/%E5%B9%B6%E6%9F%A5%E9%9B%86 . [3] LeetCode 1135. 最低成本联通所有城市 https://leetcode.cn/problems/connecting-cities-with-minimum-cost/description/ . [4] LeetCode 1584. 连接所有点的最小费用 https://leetcode.cn/problems/min-cost-to-connect-all-points/description/ . [5] 最小生成树 https://www.nowcoder.com/practice/735a34ff4672498b95660f43b7fcd628 . ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html#参考"
  },"22": {
    "doc": "并差集 - Kruskal最小生成树",
    "title": "并差集 - Kruskal最小生成树",
    "content": " ",
    "url": "/docs/Other/LeetCode/002union_find_kruskal.html",
    
    "relUrl": "/docs/Other/LeetCode/002union_find_kruskal.html"
  },"23": {
    "doc": "Excel单元格数值统计",
    "title": "题解",
    "content": "#include &lt;iostream&gt; . ",
    "url": "/docs/Other/LeetCode/101excel_count.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/101excel_count.html#题解"
  },"24": {
    "doc": "Excel单元格数值统计",
    "title": "Excel单元格数值统计",
    "content": ". ",
    "url": "/docs/Other/LeetCode/101excel_count.html",
    
    "relUrl": "/docs/Other/LeetCode/101excel_count.html"
  },"25": {
    "doc": "Linux发行版的数量",
    "title": "题解",
    "content": "#include &lt;iostream&gt; . ",
    "url": "/docs/Other/LeetCode/102linux_count.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/102linux_count.html#题解"
  },"26": {
    "doc": "Linux发行版的数量",
    "title": "Linux发行版的数量",
    "content": ". ",
    "url": "/docs/Other/LeetCode/102linux_count.html",
    
    "relUrl": "/docs/Other/LeetCode/102linux_count.html"
  },"27": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "1. 安装ImageMagick",
    "content": "sudo apt-get update sudo apt-get install imagemagick . ",
    "url": "/docs/Other/Tools/ImageMagick.html#1-%E5%AE%89%E8%A3%85imagemagick",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#1-安装imagemagick"
  },"28": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "2. 图片压缩基本指令",
    "content": "# -monitor 显示进度 # -fuzz 5% 颜色容差（color fuzz factor） # -layers Optimize 对图层进行优化处理 convert -monitor timeline05.gif -fuzz 5% -layers Optimize magick_timeline05.gif . ",
    "url": "/docs/Other/Tools/ImageMagick.html#2-%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#2-图片压缩基本指令"
  },"29": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "3. 利用Makefile一键全部压缩成magick_前缀的图片",
    "content": "# 定义 ImageMagick 命令和压缩质量变量 IMAGEMAGICK = convert FUZZ = 5% # 查找当前目录下所有未压缩的图片文件 ORIGINAL_IMAGES := $(wildcard *.png) $(wildcard *.jpg) $(wildcard *.jpeg) $(wildcard *.gif) # 过滤出需要压缩的图片文件（不包括带有前缀 \"magick_\" 的图片） TO_COMPRESS_IMAGES := $(filter-out magick_%, $(ORIGINAL_IMAGES)) # 将压缩后的图片文件名加上前缀 \"magick_\" COMPRESSED_IMAGES := $(addprefix magick_, $(TO_COMPRESS_IMAGES)) # 定义压缩所有图片的规则 compress: $(COMPRESSED_IMAGES) # 定义每个图片的压缩规则 $(COMPRESSED_IMAGES): magick_% : % @echo \"Compressing $&lt;...\" $(IMAGEMAGICK) -monitor $&lt; -fuzz $(FUZZ) -layers Optimize $@ # 定义清除所有压缩后的图片的规则 clean: rm -f magick_* . ",
    "url": "/docs/Other/Tools/ImageMagick.html#3-%E5%88%A9%E7%94%A8makefile%E4%B8%80%E9%94%AE%E5%85%A8%E9%83%A8%E5%8E%8B%E7%BC%A9%E6%88%90magick_%E5%89%8D%E7%BC%80%E7%9A%84%E5%9B%BE%E7%89%87",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#3-利用makefile一键全部压缩成magick_前缀的图片"
  },"30": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "压缩率非常惊人",
    "content": ". ",
    "url": "/docs/Other/Tools/ImageMagick.html#%E5%8E%8B%E7%BC%A9%E7%8E%87%E9%9D%9E%E5%B8%B8%E6%83%8A%E4%BA%BA",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#压缩率非常惊人"
  },"31": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "参考",
    "content": ". | 运行环境：Windows wsl, ubuntu20.04.6 | https://imagemagick.org/script/command-line-options.php | . ",
    "url": "/docs/Other/Tools/ImageMagick.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#参考"
  },"32": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "利用ImageMagick进行图片压缩",
    "content": " ",
    "url": "/docs/Other/Tools/ImageMagick.html",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html"
  },"33": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com . You can find the source code for Minima at GitHub: jekyll / minima . You can find the source code for Jekyll at GitHub: jekyll / jekyll . ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"34": {
    "doc": "Home",
    "title": "Hello World!",
    "content": " ",
    "url": "/#hello-world",
    
    "relUrl": "/#hello-world"
  },"35": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"36": {
    "doc": "Other",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "/docs/Other/#ui-components",
    
    "relUrl": "/docs/Other/#ui-components"
  },"37": {
    "doc": "Other",
    "title": "Other",
    "content": " ",
    "url": "/docs/Other/",
    
    "relUrl": "/docs/Other/"
  },"38": {
    "doc": "Tools",
    "title": "Tools",
    "content": " ",
    "url": "/docs/Other/Tools/",
    
    "relUrl": "/docs/Other/Tools/"
  },"39": {
    "doc": "LeetCode",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "/docs/Other/LeetCode/#ui-components",
    
    "relUrl": "/docs/Other/LeetCode/#ui-components"
  },"40": {
    "doc": "LeetCode",
    "title": "LeetCode",
    "content": " ",
    "url": "/docs/Other/LeetCode/",
    
    "relUrl": "/docs/Other/LeetCode/"
  },"41": {
    "doc": "Unreal",
    "title": "Hello Unreal",
    "content": " ",
    "url": "/docs/Hello/Unreal/#hello-unreal",
    
    "relUrl": "/docs/Hello/Unreal/#hello-unreal"
  },"42": {
    "doc": "Unreal",
    "title": "Unreal",
    "content": " ",
    "url": "/docs/Hello/Unreal/",
    
    "relUrl": "/docs/Hello/Unreal/"
  },"43": {
    "doc": "Hello",
    "title": "Hello",
    "content": " ",
    "url": "/docs/Hello/",
    
    "relUrl": "/docs/Hello/"
  }
}
