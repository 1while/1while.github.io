{"0": {
    "doc": "Unreal入门，门01，自动开启的门",
    "title": "Unreal入门，门01，自动开启的门",
    "content": " ",
    "url": "/docs/Hello/Unreal/001Door/001TheDoor01.html",
    
    "relUrl": "/docs/Hello/Unreal/001Door/001TheDoor01.html"
  },"1": {
    "doc": "Excel单元格数值统计",
    "title": "题解",
    "content": "#include &lt;iostream&gt; . ",
    "url": "/docs/Other/LeetCode/001excel_count.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/001excel_count.html#题解"
  },"2": {
    "doc": "Excel单元格数值统计",
    "title": "Excel单元格数值统计",
    "content": ". ",
    "url": "/docs/Other/LeetCode/001excel_count.html",
    
    "relUrl": "/docs/Other/LeetCode/001excel_count.html"
  },"3": {
    "doc": "并差集",
    "title": "并查集",
    "content": "并查集（Disjoint Set）是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。 . 并查集的主要操作如下： . | makeSet(s)：建立一个新的并查集，其中包含s个单元素集合。 | unionSet(x, y)：若x和y不在同一集合，则将x和y所在的集合合并为一个集合。 | findSet(x)：查找元素x所在的集合，返回该集合的代表元素。 | . 并查集的基本思想是维护一个由树组成的森林，其中每个节点都有一个父节点指针指向它的父节点。初始时，每个节点自成一个集合，即它们的父节点都指向自己。每次进行合并操作时，将两个集合的根节点连接起来，使其中一个根节点成为另一个根节点的子节点。这样，就可以通过检查某个节点的祖先，来确定它所属的集合。 . 并查集的主要优点是在合并和查询操作中具有较高的效率，时间复杂度均为O(log n)。并查集常用于解决图论中的连通性问题，如最小生成树、最大流等算法中。 . ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%B9%B6%E6%9F%A5%E9%9B%86",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#并查集"
  },"4": {
    "doc": "并差集",
    "title": "LeetCode547. 省份数量",
    "content": "有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 . 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 . 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 . 返回矩阵中 省份 的数量。 . ",
    "url": "/docs/Other/LeetCode/001union_find.html#leetcode547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#leetcode547-省份数量"
  },"5": {
    "doc": "并差集",
    "title": "并差集题解",
    "content": " ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%B9%B6%E5%B7%AE%E9%9B%86%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#并差集题解"
  },"6": {
    "doc": "并差集",
    "title": "1. 初始化，确定各个城市省份关系之前，先假定每个城市都是一个省份，省份就是自己，差不多就是直辖市的感觉",
    "content": ". // MAX_CITY_N城市数量 int city[MAX_CITY_N]; void init() { // 用索引id代表城市，数组的值代表省份id for (int i=0; i&lt;MAX_CITY_N; i++) { // 自己就是自己的省份，省份值即城市id city[i] = i; } } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A1%AE%E5%AE%9A%E5%90%84%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9C%81%E4%BB%BD%E5%85%B3%E7%B3%BB%E4%B9%8B%E5%89%8D%E5%85%88%E5%81%87%E5%AE%9A%E6%AF%8F%E4%B8%AA%E5%9F%8E%E5%B8%82%E9%83%BD%E6%98%AF%E4%B8%80%E4%B8%AA%E7%9C%81%E4%BB%BD%E7%9C%81%E4%BB%BD%E5%B0%B1%E6%98%AF%E8%87%AA%E5%B7%B1%E5%B7%AE%E4%B8%8D%E5%A4%9A%E5%B0%B1%E6%98%AF%E7%9B%B4%E8%BE%96%E5%B8%82%E7%9A%84%E6%84%9F%E8%A7%89",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#1-初始化确定各个城市省份关系之前先假定每个城市都是一个省份省份就是自己差不多就是直辖市的感觉"
  },"7": {
    "doc": "并差集",
    "title": "2. 基本合并算法，两个城市如果直接相连，则表示它们属于同一个省份，将其中一个的省份值设置为对方的省份值",
    "content": ". city[indexB] = city[indexA]; . 或者反过来（这里先以上面的为准） . city[indexA] = city[indexB]; . 2.1 继续合并，假设B和C相连，将C的省份值设置为B的省份值 . city[indexC] = city[indexB]; . 实际上前面的操作之后，B的省份值是A的省份值 . city[indexC] = city[indexA]; . ",
    "url": "/docs/Other/LeetCode/001union_find.html#2-%E5%9F%BA%E6%9C%AC%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95%E4%B8%A4%E4%B8%AA%E5%9F%8E%E5%B8%82%E5%A6%82%E6%9E%9C%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%E5%88%99%E8%A1%A8%E7%A4%BA%E5%AE%83%E4%BB%AC%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E4%B8%AA%E7%9C%81%E4%BB%BD%E5%B0%86%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E7%9A%84%E7%9C%81%E4%BB%BD%E5%80%BC%E8%AE%BE%E7%BD%AE%E4%B8%BA%E5%AF%B9%E6%96%B9%E7%9A%84%E7%9C%81%E4%BB%BD%E5%80%BC",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#2-基本合并算法两个城市如果直接相连则表示它们属于同一个省份将其中一个的省份值设置为对方的省份值"
  },"8": {
    "doc": "并差集",
    "title": "3. 根省份与查找算法，前面合并之后B和C的省份都变成了A，而A的省份也是A，这里就可以将A确认为根省份了，这里就可以确认查找根省份的算法了：",
    "content": "// 返回省份值，也是一个cityIndex int find(int cityIndex) { // 假定从indexC开始查找，递归到indexA // city[indexA] == indexA，则indexA是indexC的省份 if (city[cityIndex] == cityIndex) { return cityIndex; } // city[indexC] != indexC，所以需要继续find return find(city[cityIndex]); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#3-%E6%A0%B9%E7%9C%81%E4%BB%BD%E4%B8%8E%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E5%89%8D%E9%9D%A2%E5%90%88%E5%B9%B6%E4%B9%8B%E5%90%8Eb%E5%92%8Cc%E7%9A%84%E7%9C%81%E4%BB%BD%E9%83%BD%E5%8F%98%E6%88%90%E4%BA%86a%E8%80%8Ca%E7%9A%84%E7%9C%81%E4%BB%BD%E4%B9%9F%E6%98%AFa%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86a%E7%A1%AE%E8%AE%A4%E4%B8%BA%E6%A0%B9%E7%9C%81%E4%BB%BD%E4%BA%86%E8%BF%99%E9%87%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%A1%AE%E8%AE%A4%E6%9F%A5%E6%89%BE%E6%A0%B9%E7%9C%81%E4%BB%BD%E7%9A%84%E7%AE%97%E6%B3%95%E4%BA%86",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#3-根省份与查找算法前面合并之后b和c的省份都变成了a而a的省份也是a这里就可以将a确认为根省份了这里就可以确认查找根省份的算法了"
  },"9": {
    "doc": "并差集",
    "title": "4. 基于根省份的合并算法，将其中一个城市的根省份赋值给另一个城市的根省份",
    "content": "void merge(int indexA, int indexB) { // 先查找A城市的根省份 int rootProvinceOfA = find(indexA); // 然后将A城市的根省份作为B城市的新省份 city[indexB] = rootProvinceOfA; } . 简化一下： . void merge(int indexA, int indexB) { city[indexB] = find(indexA); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#4-%E5%9F%BA%E4%BA%8E%E6%A0%B9%E7%9C%81%E4%BB%BD%E7%9A%84%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95%E5%B0%86%E5%85%B6%E4%B8%AD%E4%B8%80%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E6%A0%B9%E7%9C%81%E4%BB%BD%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%A6%E4%B8%80%E4%B8%AA%E5%9F%8E%E5%B8%82%E7%9A%84%E6%A0%B9%E7%9C%81%E4%BB%BD",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#4-基于根省份的合并算法将其中一个城市的根省份赋值给另一个城市的根省份"
  },"10": {
    "doc": "并差集",
    "title": "4.1 合并问题，如果出现下图的关系，按照上面的算法，会导致最终结算出两个根节点，而实际上它们都是联通的，只应该出现一个根节点，所以合并的时候需要先定位到根节点，让根节点去参与合并操作",
    "content": ". | 根节点不准问题 merge(A, B); // 连线AB，A为根 merge(A, D); // 连线AD，A为根 merge(C, D); // 连线CD，D的根变成了C，出现了AC两个根，但是它们实际都是联通的 . | 所以合并算法需要考虑让两个节点的根节点相互联通，而不只是其中一个作为根参与联通 | . void merge(int indexA, int indexB) { int rootOfA = find(indexA); int rootOfB = find(indexB); city[rootOfB] = rootOfA; } . 简化一下： . void merge(int indexA, int indexB) { city[find(indexB)] = find(indexA); } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#41-%E5%90%88%E5%B9%B6%E9%97%AE%E9%A2%98%E5%A6%82%E6%9E%9C%E5%87%BA%E7%8E%B0%E4%B8%8B%E5%9B%BE%E7%9A%84%E5%85%B3%E7%B3%BB%E6%8C%89%E7%85%A7%E4%B8%8A%E9%9D%A2%E7%9A%84%E7%AE%97%E6%B3%95%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%9C%80%E7%BB%88%E7%BB%93%E7%AE%97%E5%87%BA%E4%B8%A4%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E8%80%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E5%AE%83%E4%BB%AC%E9%83%BD%E6%98%AF%E8%81%94%E9%80%9A%E7%9A%84%E5%8F%AA%E5%BA%94%E8%AF%A5%E5%87%BA%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%A0%B9%E8%8A%82%E7%82%B9%E6%89%80%E4%BB%A5%E5%90%88%E5%B9%B6%E7%9A%84%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%85%88%E5%AE%9A%E4%BD%8D%E5%88%B0%E6%A0%B9%E8%8A%82%E7%82%B9%E8%AE%A9%E6%A0%B9%E8%8A%82%E7%82%B9%E5%8E%BB%E5%8F%82%E4%B8%8E%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#41-合并问题如果出现下图的关系按照上面的算法会导致最终结算出两个根节点而实际上它们都是联通的只应该出现一个根节点所以合并的时候需要先定位到根节点让根节点去参与合并操作"
  },"11": {
    "doc": "并差集",
    "title": "4.2 合并成链问题，下面这种合并顺序下，搜索路径会变成一条长长的链条，搜索的时间复杂度退化成O(n)，这里可以考虑增加一个深度信息，合并的时候，让深度值高的根节点作为新的根",
    "content": ". | 合并成链问题 merge(C, D); // 连线CD，C为根 merge(B, C); // 连线BC，B为根 merge(A, B); // 连线AB，A为根 . | 深度值高的作为新的根 merge(C, D); // 连线CD，C为根 merge(B, C); // 连线BC，C深度为2，B深度为1，C作为新的根 merge(A, B); // 连线AB，B的根是C，所以这里是连接AC，C的深度当前为3，所以C继续作为新的根 . | 新的初始化，带深度信息 // MAX_CITY_N城市数量 int city[MAX_CITY_N]; int depth[MAX_CITY_N]; void init() { // 用索引id代表城市，数组的值代表省份id for (int i=0; i&lt;MAX_CITY_N; i++) { // 自己就是自己的省份，省份值即城市id city[i] = i; depth[i] = 1; } } . | 新的合并算法 void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } . | . ",
    "url": "/docs/Other/LeetCode/001union_find.html#42-%E5%90%88%E5%B9%B6%E6%88%90%E9%93%BE%E9%97%AE%E9%A2%98%E4%B8%8B%E9%9D%A2%E8%BF%99%E7%A7%8D%E5%90%88%E5%B9%B6%E9%A1%BA%E5%BA%8F%E4%B8%8B%E6%90%9C%E7%B4%A2%E8%B7%AF%E5%BE%84%E4%BC%9A%E5%8F%98%E6%88%90%E4%B8%80%E6%9D%A1%E9%95%BF%E9%95%BF%E7%9A%84%E9%93%BE%E6%9D%A1%E6%90%9C%E7%B4%A2%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%80%80%E5%8C%96%E6%88%90on%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E8%80%83%E8%99%91%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E4%BF%A1%E6%81%AF%E5%90%88%E5%B9%B6%E7%9A%84%E6%97%B6%E5%80%99%E8%AE%A9%E6%B7%B1%E5%BA%A6%E5%80%BC%E9%AB%98%E7%9A%84%E6%A0%B9%E8%8A%82%E7%82%B9%E4%BD%9C%E4%B8%BA%E6%96%B0%E7%9A%84%E6%A0%B9",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#42-合并成链问题下面这种合并顺序下搜索路径会变成一条长长的链条搜索的时间复杂度退化成on这里可以考虑增加一个深度信息合并的时候让深度值高的根节点作为新的根"
  },"12": {
    "doc": "并差集",
    "title": "5. 统计省份，只用统计根节点即可",
    "content": "int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { // 索引和当前的值相等即为根节点 if (city[i] == i) { counter++; } } return counter; } . ",
    "url": "/docs/Other/LeetCode/001union_find.html#5-%E7%BB%9F%E8%AE%A1%E7%9C%81%E4%BB%BD%E5%8F%AA%E7%94%A8%E7%BB%9F%E8%AE%A1%E6%A0%B9%E8%8A%82%E7%82%B9%E5%8D%B3%E5%8F%AF",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#5-统计省份只用统计根节点即可"
  },"13": {
    "doc": "并差集",
    "title": "6. 完整代码",
    "content": "#include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;set&gt; using namespace std; namespace UnionFindTest { class UnionFind { public: UnionFind(int n) : depth(n, 1){ city.reserve(n); for (int i = 0; i &lt; n; i++) { city.push_back(i); } } int find(int cityIndex) const { if (city[cityIndex] == cityIndex) { return cityIndex; } return find(city[cityIndex]); } void merge(int indexA, int indexB) { int rootA = find(indexA); int rootB = find(indexB); if (depth[rootA] &gt; depth[rootB]) { city[rootB] = city[rootA]; ++depth[rootA]; } else { city[rootA] = city[rootB]; ++depth[rootB]; } } int count() { int counter = 0; for (int i = 0; i &lt; city.size(); i++) { if (city[i] == i) { counter++; } } return counter; } private: vector&lt;int&gt; city; vector&lt;int&gt; depth; }; class Solution { public: static int findCircleNum(const vector&lt;vector&lt;int&gt;&gt;&amp; isConnected) { UnionFind uf(isConnected.size()); for (int i = 0; i &lt; isConnected.size(); i++) { for (int j = 0; j &lt; isConnected[i].size(); j++) { if (isConnected[i][j]) { uf.merge(i, j); } } } return uf.count(); } }; void Test() { // 2 vector&lt;vector&lt;int&gt;&gt; isConnected = { {1,1,0}, {1,1,0}, {0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; // 3 isConnected = { {1,0,0}, {0,1,0}, {0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; // 3 isConnected = { {1,1,0,0,0,0,0,1,0,0,0,0,0,0,0}, {1,1,0,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,1,0,0,0,0,0,0,0,0,0,0,0,0}, {0,0,0,1,0,1,1,0,0,0,0,0,0,0,0}, {0,0,0,0,1,0,0,0,0,1,1,0,0,0,0}, {0,0,0,1,0,1,0,0,0,0,1,0,0,0,0}, {0,0,0,1,0,0,1,0,1,0,0,0,0,1,0}, {1,0,0,0,0,0,0,1,1,0,0,0,0,0,0}, {0,0,0,0,0,0,1,1,1,0,0,0,0,1,0}, {0,0,0,0,1,0,0,0,0,1,0,1,0,0,1}, {0,0,0,0,1,1,0,0,0,0,1,1,0,0,0}, {0,0,0,0,0,0,0,0,0,1,1,1,0,0,0}, {0,0,0,0,0,0,0,0,0,0,0,0,1,0,0}, {0,0,0,0,0,0,1,0,1,0,0,0,0,1,0}, {0,0,0,0,0,0,0,0,0,1,0,0,0,0,1}}; cout &lt;&lt; Solution::findCircleNum(isConnected) &lt;&lt; endl; } } // namespace UnionFindTest . ",
    "url": "/docs/Other/LeetCode/001union_find.html#6-%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#6-完整代码"
  },"14": {
    "doc": "并差集",
    "title": "参考",
    "content": "[1] LeetCode547. 省份数量: https://leetcode.cn/problems/number-of-provinces/description/ . [2] 并查集: https://zh.wikipedia.org/zh-cn/%E5%B9%B6%E6%9F%A5%E9%9B%86 . ",
    "url": "/docs/Other/LeetCode/001union_find.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html#参考"
  },"15": {
    "doc": "并差集",
    "title": "并差集",
    "content": " ",
    "url": "/docs/Other/LeetCode/001union_find.html",
    
    "relUrl": "/docs/Other/LeetCode/001union_find.html"
  },"16": {
    "doc": "Unreal入门，门02，锁住的门",
    "title": "Unreal入门，门02，锁住的门",
    "content": " ",
    "url": "/docs/Hello/Unreal/001Door/002TheDoor02.html",
    
    "relUrl": "/docs/Hello/Unreal/001Door/002TheDoor02.html"
  },"17": {
    "doc": "Linux发行版的数量",
    "title": "题解",
    "content": "#include &lt;iostream&gt; . ",
    "url": "/docs/Other/LeetCode/002linux_count.html#%E9%A2%98%E8%A7%A3",
    
    "relUrl": "/docs/Other/LeetCode/002linux_count.html#题解"
  },"18": {
    "doc": "Linux发行版的数量",
    "title": "Linux发行版的数量",
    "content": ". ",
    "url": "/docs/Other/LeetCode/002linux_count.html",
    
    "relUrl": "/docs/Other/LeetCode/002linux_count.html"
  },"19": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "1. 安装ImageMagick",
    "content": "sudo apt-get update sudo apt-get install imagemagick . ",
    "url": "/docs/Other/Tools/ImageMagick.html#1-%E5%AE%89%E8%A3%85imagemagick",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#1-安装imagemagick"
  },"20": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "2. 图片压缩基本指令",
    "content": "# -monitor 显示进度 # -fuzz 5% 颜色容差（color fuzz factor） # -layers Optimize 对图层进行优化处理 convert -monitor timeline05.gif -fuzz 5% -layers Optimize magick_timeline05.gif . ",
    "url": "/docs/Other/Tools/ImageMagick.html#2-%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#2-图片压缩基本指令"
  },"21": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "3. 利用Makefile一键全部压缩成magick_前缀的图片",
    "content": "# 定义 ImageMagick 命令和压缩质量变量 IMAGEMAGICK = convert FUZZ = 5% # 查找当前目录下所有未压缩的图片文件 ORIGINAL_IMAGES := $(wildcard *.png) $(wildcard *.jpg) $(wildcard *.jpeg) $(wildcard *.gif) # 过滤出需要压缩的图片文件（不包括带有前缀 \"magick_\" 的图片） TO_COMPRESS_IMAGES := $(filter-out magick_%, $(ORIGINAL_IMAGES)) # 将压缩后的图片文件名加上前缀 \"magick_\" COMPRESSED_IMAGES := $(addprefix magick_, $(TO_COMPRESS_IMAGES)) # 定义压缩所有图片的规则 compress: $(COMPRESSED_IMAGES) # 定义每个图片的压缩规则 $(COMPRESSED_IMAGES): magick_% : % @echo \"Compressing $&lt;...\" $(IMAGEMAGICK) -monitor $&lt; -fuzz $(FUZZ) -layers Optimize $@ # 定义清除所有压缩后的图片的规则 clean: rm -f magick_* . ",
    "url": "/docs/Other/Tools/ImageMagick.html#3-%E5%88%A9%E7%94%A8makefile%E4%B8%80%E9%94%AE%E5%85%A8%E9%83%A8%E5%8E%8B%E7%BC%A9%E6%88%90magick_%E5%89%8D%E7%BC%80%E7%9A%84%E5%9B%BE%E7%89%87",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#3-利用makefile一键全部压缩成magick_前缀的图片"
  },"22": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "压缩率非常惊人",
    "content": ". ",
    "url": "/docs/Other/Tools/ImageMagick.html#%E5%8E%8B%E7%BC%A9%E7%8E%87%E9%9D%9E%E5%B8%B8%E6%83%8A%E4%BA%BA",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#压缩率非常惊人"
  },"23": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "参考",
    "content": ". | 运行环境：Windows wsl, ubuntu20.04.6 | https://imagemagick.org/script/command-line-options.php | . ",
    "url": "/docs/Other/Tools/ImageMagick.html#%E5%8F%82%E8%80%83",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html#参考"
  },"24": {
    "doc": "利用ImageMagick进行图片压缩",
    "title": "利用ImageMagick进行图片压缩",
    "content": " ",
    "url": "/docs/Other/Tools/ImageMagick.html",
    
    "relUrl": "/docs/Other/Tools/ImageMagick.html"
  },"25": {
    "doc": "About",
    "title": "About",
    "content": "This is the base Jekyll theme. You can find out more info about customizing your Jekyll theme, as well as basic Jekyll usage documentation at jekyllrb.com . You can find the source code for Minima at GitHub: jekyll / minima . You can find the source code for Jekyll at GitHub: jekyll / jekyll . ",
    "url": "/about/",
    
    "relUrl": "/about/"
  },"26": {
    "doc": "Home",
    "title": "Hello World!",
    "content": " ",
    "url": "/#hello-world",
    
    "relUrl": "/#hello-world"
  },"27": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"28": {
    "doc": "Other",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "/docs/Other/#ui-components",
    
    "relUrl": "/docs/Other/#ui-components"
  },"29": {
    "doc": "Other",
    "title": "Other",
    "content": " ",
    "url": "/docs/Other/",
    
    "relUrl": "/docs/Other/"
  },"30": {
    "doc": "Hello",
    "title": "Hello",
    "content": " ",
    "url": "/docs/Hello/",
    
    "relUrl": "/docs/Hello/"
  },"31": {
    "doc": "Unreal",
    "title": "Hello Unreal",
    "content": " ",
    "url": "/docs/Hello/Unreal/#hello-unreal",
    
    "relUrl": "/docs/Hello/Unreal/#hello-unreal"
  },"32": {
    "doc": "Unreal",
    "title": "Unreal",
    "content": " ",
    "url": "/docs/Hello/Unreal/",
    
    "relUrl": "/docs/Hello/Unreal/"
  },"33": {
    "doc": "LeetCode",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "/docs/Other/LeetCode/#ui-components",
    
    "relUrl": "/docs/Other/LeetCode/#ui-components"
  },"34": {
    "doc": "LeetCode",
    "title": "LeetCode",
    "content": " ",
    "url": "/docs/Other/LeetCode/",
    
    "relUrl": "/docs/Other/LeetCode/"
  },"35": {
    "doc": "Tools",
    "title": "Tools",
    "content": " ",
    "url": "/docs/Other/Tools/",
    
    "relUrl": "/docs/Other/Tools/"
  }
}
